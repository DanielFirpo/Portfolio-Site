{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\DF\\\\Documents\\\\GitHub\\\\Lambda\\\\PortfolioSite\\\\portfolio\\\\src\\\\components\\\\Game.js\";\nimport React, { useEffect, useState } from 'react';\nimport Char from \"../GameLogic/Char\";\nlet mousePos = {\n  x: 0,\n  y: 0\n};\n\nfunction Game() {\n  const [canvas, setCanvas] = useState();\n  const [size, setSize] = useState();\n  let canvasRef = React.createRef();\n  useEffect(() => {\n    setCanvas(canvasRef.current);\n    console.log(\"Canvas:\", canvas);\n    resizeCanvas(); //do an initial resize for when it first renders, this function will also be called every time the window is resized too\n  }, [canvasRef]);\n  useEffect(() => {\n    window.addEventListener('resize', resizeCanvas);\n  });\n\n  function resizeCanvas() {\n    if (canvas) {\n      canvas.width = window.innerWidth;\n      canvas.height = window.innerHeight;\n    }\n  }\n\n  if (canvas) {\n    let c = canvas.getContext(\"2d\");\n    c.fillRect(100, 100, 100, 100);\n    let fontSize = 30;\n    c.font = fontSize + 'px ' + 'Arial';\n    c.lineWidth = 2;\n    c.textBaseline = 'middle';\n    c.textAlign = 'center';\n    c.fillStyle = \"white\";\n    let originalText = \"Helllllo world! ! !!! Spacing test\";\n    let totalOffset = 0;\n    let characters = []; //initialize by filling characters array with Chars for each character in text\n\n    for (let i = 0; i < originalText.length; i++) {\n      let position = {\n        x: window.innerWidth / 2 - c.measureText(originalText).width / 2 + (totalOffset + c.measureText(originalText[i]).width / 2),\n        y: window.innerHeight / 2\n      };\n      let char = new Char(originalText[i], position, c.measureText(originalText[i]).width, i);\n      characters.push(char);\n      totalOffset += c.measureText(originalText[i]).width;\n    }\n\n    let lastTime;\n\n    function frame(currentTime) {\n      c.clearRect(0, 0, canvas.width, canvas.height); //clear previous frame\n\n      if (!lastTime) lastTime = currentTime;\n      let deltaTime = currentTime - lastTime; //time since last frame\n\n      lastTime = currentTime; //draw chars\n\n      characters.forEach(char => {\n        c.fillText(char.text, char.position.x, char.position.y);\n      }); //draw paddle\n\n      console.log(\"mouse pos\", mousePos);\n      let paddleWidth = 100;\n      c.fillRect(mousePos.x - paddleWidth / 2, window.innerHeight / 10, paddleWidth, 10);\n      requestAnimationFrame(frame);\n    }\n\n    frame(); //get the frame loop going\n  }\n\n  return React.createElement(\"canvas\", {\n    onMouseMove: e => {\n      mousePos = {\n        x: e.pageX,\n        y: e.pageY\n      };\n    },\n    ref: canvasRef,\n    id: \"game\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86\n    },\n    __self: this\n  });\n}\n\nexport default Game; //  // to count each character \n//  var charIndex = 0;\n//  // find the top ypos and then move down half a char space\n//  var yPos = centerY - fontSize * line.length * 0.5 * textVertSpacing + fontSize * textVertSpacing / 2;\n//  for (var i = 0; i < line.length; i++) {\n//    // get the width of the whole line\n//    var width = ctx.measureText(line[i]).width;\n//    // use the width to find start\n//    var textPosX = centerX - width / 2;\n//    for (var j = 0; j < line[i].length; j++) {\n//      // get char\n//      var char = line[i][j];\n//      // get its width\n//      var cWidth = ctx.measureText(char).width;\n//      // check if char needs to fade\n//      if (fade.indexOf(charIndex) > -1) {\n//        ctx.globalAlpha = 0.5;\n//      } else {\n//        ctx.globalAlpha = 1;\n//      }\n//      // draw the char offset by half its width (center)\n//      ctx.fillText(char, textPosX + cWidth / 2, yPos);\n//      // move too the next pos\n//      textPosX += cWidth;\n//      // count the char\n//      charIndex += 1\n//    }\n//    // move down one line\n//    yPos += fontSize * textVertSpacing;\n//  }\n// }","map":{"version":3,"sources":["C:/Users/DF/Documents/GitHub/Lambda/PortfolioSite/portfolio/src/components/Game.js"],"names":["React","useEffect","useState","Char","mousePos","x","y","Game","canvas","setCanvas","size","setSize","canvasRef","createRef","current","console","log","resizeCanvas","window","addEventListener","width","innerWidth","height","innerHeight","c","getContext","fillRect","fontSize","font","lineWidth","textBaseline","textAlign","fillStyle","originalText","totalOffset","characters","i","length","position","measureText","char","push","lastTime","frame","currentTime","clearRect","deltaTime","forEach","fillText","text","paddleWidth","requestAnimationFrame","e","pageX","pageY"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport Char from \"../GameLogic/Char\";\r\n\r\nlet mousePos = {x: 0, y: 0};\r\n\r\nfunction Game() {\r\n\r\n    const [canvas, setCanvas] = useState();\r\n    const [size, setSize] = useState();\r\n\r\n    let canvasRef = React.createRef();\r\n\r\n    useEffect(() => {\r\n        setCanvas(canvasRef.current);\r\n        console.log(\"Canvas:\", canvas)\r\n        resizeCanvas();//do an initial resize for when it first renders, this function will also be called every time the window is resized too\r\n    }, [canvasRef])\r\n\r\n    useEffect(() => {\r\n        window.addEventListener('resize', resizeCanvas)\r\n    })\r\n\r\n    function resizeCanvas() {\r\n        if (canvas) {\r\n            canvas.width = window.innerWidth;\r\n            canvas.height = window.innerHeight;\r\n        }\r\n    }\r\n\r\n    if (canvas) {\r\n\r\n        let c = canvas.getContext(\"2d\");\r\n\r\n        c.fillRect(100, 100, 100, 100);\r\n\r\n        let fontSize = 30\r\n\r\n        c.font = fontSize + 'px ' + 'Arial';\r\n        c.lineWidth = 2;\r\n        c.textBaseline = 'middle';\r\n        c.textAlign = 'center';\r\n        c.fillStyle = \"white\";\r\n\r\n        let originalText = \"Helllllo world! ! !!! Spacing test\";\r\n        let totalOffset = 0;\r\n\r\n        let characters = []\r\n\r\n        //initialize by filling characters array with Chars for each character in text\r\n        for (let i = 0; i < originalText.length; i++) {\r\n            let position = { x: window.innerWidth / 2 - c.measureText(originalText).width / 2 + (totalOffset + c.measureText(originalText[i]).width / 2), y: window.innerHeight / 2 }\r\n            let char = new Char(originalText[i], position, c.measureText(originalText[i]).width, i);\r\n            characters.push(char);\r\n            totalOffset += c.measureText(originalText[i]).width;\r\n        }\r\n\r\n        let lastTime;\r\n\r\n        function frame(currentTime) {\r\n\r\n            c.clearRect(0, 0, canvas.width, canvas.height);//clear previous frame\r\n\r\n            if (!lastTime) lastTime = currentTime;\r\n            let deltaTime = currentTime - lastTime;//time since last frame\r\n            lastTime = currentTime;\r\n\r\n            //draw chars\r\n            characters.forEach((char) => {\r\n                c.fillText(char.text, char.position.x, char.position.y)\r\n            });\r\n\r\n            //draw paddle\r\n            console.log(\"mouse pos\", mousePos);\r\n            let paddleWidth = 100;\r\n            c.fillRect(mousePos.x - paddleWidth/2, window.innerHeight/10, paddleWidth, 10);\r\n\r\n            requestAnimationFrame(frame);\r\n        }\r\n\r\n        frame();//get the frame loop going\r\n\r\n    }\r\n\r\n\r\n    return (\r\n        <canvas onMouseMove={(e) => {mousePos={x: e.pageX, y: e.pageY}}} ref={canvasRef} id=\"game\"></canvas>\r\n    );\r\n}\r\n\r\nexport default Game;\r\n\r\n//  // to count each character \r\n//  var charIndex = 0;\r\n//  // find the top ypos and then move down half a char space\r\n//  var yPos = centerY - fontSize * line.length * 0.5 * textVertSpacing + fontSize * textVertSpacing / 2;\r\n\r\n//  for (var i = 0; i < line.length; i++) {\r\n//    // get the width of the whole line\r\n//    var width = ctx.measureText(line[i]).width;\r\n//    // use the width to find start\r\n//    var textPosX = centerX - width / 2;\r\n//    for (var j = 0; j < line[i].length; j++) {\r\n//      // get char\r\n//      var char = line[i][j];\r\n//      // get its width\r\n//      var cWidth = ctx.measureText(char).width;\r\n//      // check if char needs to fade\r\n//      if (fade.indexOf(charIndex) > -1) {\r\n//        ctx.globalAlpha = 0.5;\r\n//      } else {\r\n//        ctx.globalAlpha = 1;\r\n//      }\r\n//      // draw the char offset by half its width (center)\r\n//      ctx.fillText(char, textPosX + cWidth / 2, yPos);\r\n//      // move too the next pos\r\n//      textPosX += cWidth;\r\n//      // count the char\r\n//      charIndex += 1\r\n//    }\r\n//    // move down one line\r\n//    yPos += fontSize * textVertSpacing;\r\n//  }\r\n// }\r\n"]},"metadata":{},"sourceType":"module"}